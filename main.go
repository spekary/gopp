package main

/**
gopp

Gopp or go-plus-plus, is an attempt to make object oriented features of go like virtual functions more accessible.

It is currently structured as a pre-processor that can be run with go-generate, and that takes in a .gpp file and
outputs standard .go code.

The primary feature is a new keyword "class", that operates similarly to the "class" keyword in PHP, and begins the
definition of an object. This single object definition gets converted to both a struct and interface in standard go
code such that you can do things like:

obj.DoVirtualFunc()

or

obj.member = 7

and the resulting code will find the correct function or member of the struct and use it, including functions of subclasses.
The result is the ability for programmers who are accustomed to writing object oriented code like PHP or C++ to work the way they like, and
not have to worry about all the implementation details of writing similar code in strict go.

Syntax:

A class definition begins with the word "class", followed by a class name, the required word "extends" and a superclass.

To create a base class, you should extend the "Base" class. The Base class is a struct and interface combination that
implement basic object primitives that are often found in object oriented languages.

 */

import (
	"flag"
	"os"
	"fmt"
	"io/ioutil"
	"strings"
	"path/filepath"
)

func processFile(file string) {
	s,err := ioutil.ReadFile(file)

	if (err != nil) {
		fmt.Println(err)
		return
	}
	s = ProcessString(s)
	i := strings.LastIndex(file, ".")

	if (i < 0) {
		file = file + ".go"
	} else {
		file = file[:i] + ".go"
	}
	ioutil.WriteFile(file, s, os.ModePerm)
}

/**
Process a string that is gopp formatted code, and return the go code
 */
func ProcessString(input []byte) []byte {
	l := lex(string(input))

	tree := parse(l)
	s := tree.String()

	s = "/**\nThis file is code generated by gopp. Do not edit.\n*/\n\n" + s

	return []byte(s)
}


func main() {
	var all bool
	args := os.Args[1:]

	if (len(args) == 0) {
		fmt.Println("Usage: gopp [file ...] [-all]")
		fmt.Println("-all: process all .gpp files in the current directory")
	}

	flag.BoolVar(&all, "all", false, "a string var")


	flag.Parse()
	//var err error

	if all {
		// Process all files
		files, _ := filepath.Glob("*.gpp")
		if len(files) == 0 {
			fmt.Println("No .gpp files found in current directory.")
			return
		}
		for _, file := range files {
			processFile(file)
		}
	} else {
		for _, file := range args {
			processFile(file)
		}
	}
}


